diff --git a/app/lyrics_service/config.py b/app/lyrics_service/config.py
index 1234567..abcdefg 100644
--- a/app/lyrics_service/config.py
+++ b/app/lyrics_service/config.py
@@ -44,6 +44,11 @@ TEMPERATURE = float(os.getenv("LYRICS_TEMPERATURE", "0.0"))
 ENABLE_WORD_TIMESTAMPS = os.getenv("LYRICS_ENABLE_WORD_TIMESTAMPS", "true").lower() == "true"
 MAX_CHARS_PER_LINE = int(os.getenv("LYRICS_MAX_CHARS_PER_LINE", "60"))
 LINE_GAP_THRESHOLD = float(os.getenv("LYRICS_LINE_GAP_THRESHOLD", "0.8"))
 STANZA_GAP_THRESHOLD = float(os.getenv("LYRICS_STANZA_GAP_THRESHOLD", "2.5"))
 
+# Uppercase-based line breaking (fallback when timing gaps don't produce breaks)
+ENABLE_UPPERCASE_BREAKS = os.getenv("LYRICS_ENABLE_UPPERCASE_BREAKS", "true").lower() == "true"
+MIN_CHARS_BEFORE_UPPER_BREAK = int(os.getenv("LYRICS_MIN_CHARS_BEFORE_UPPER_BREAK", "18"))
+MIN_WORDS_BEFORE_UPPER_BREAK = int(os.getenv("LYRICS_MIN_WORDS_BEFORE_UPPER_BREAK", "4"))
+
 # Concurrency

diff --git a/app/lyrics_service/pipeline/postprocess.py b/app/lyrics_service/pipeline/postprocess.py
index 1234567..abcdefg 100644
--- a/app/lyrics_service/pipeline/postprocess.py
+++ b/app/lyrics_service/pipeline/postprocess.py
@@ -6,6 +6,8 @@ Pure Python heuristics only - no LLM dependency.
 import logging
 import re
 from typing import List, Dict, Optional
+
+from app.lyrics_service import config
 
 logger = logging.getLogger(__name__)
 
@@ -107,13 +109,18 @@ COMPILED_NOISE_PATTERNS = [re.compile(pattern, re.IGNORECASE) for pattern in NO
 def format_lyrics_from_words(
     segments: List[Dict],
     max_chars_per_line: int = 60,
     line_gap_threshold: float = 0.8,
-    stanza_gap_threshold: float = 2.5
+    stanza_gap_threshold: float = 2.5,
+    uppercase_break: bool = True,
+    min_chars_before_upper_break: int = 18,
+    min_words_before_upper_break: int = 4
 ) -> tuple[str, List[Dict]]:
     """
     Format lyrics from word-level timestamps with intelligent line/stanza breaks.
     
     Args:
         segments: List of segment dicts with 'words' arrays
         max_chars_per_line: Maximum characters per line (soft limit)
         line_gap_threshold: Time gap (seconds) to trigger new line
         stanza_gap_threshold: Time gap (seconds) to trigger stanza break
+        uppercase_break: Enable line breaks before uppercase words
+        min_chars_before_upper_break: Minimum chars in line before uppercase break
+        min_words_before_upper_break: Minimum words in line before uppercase break
     
     Returns:
         (formatted_lyrics_text, word_timestamps_list)
@@ -151,6 +158,16 @@ def format_lyrics_from_words(
         return ' '.join(result)
     
+    def starts_with_uppercase(word: str) -> bool:
+        """Check if word starts with an uppercase letter (Unicode-aware)."""
+        word = word.strip()
+        if not word:
+            return False
+        first_char = word[0]
+        return first_char.isalpha() and first_char.isupper()
+    
     if not segments:
         return "", []
     
@@ -175,24 +192,44 @@ def format_lyrics_from_words(
     # Build lines based on timing gaps and character limits
     lines = []
     current_line = []
     current_line_chars = 0
+    current_line_words = 0  # Track word count (non-punctuation)
     prev_end = 0.0
     
     for i, word_info in enumerate(all_words):
         word = word_info['word']
         start = word_info['start']
         end = word_info['end']
         gap = start - prev_end if i > 0 else 0.0
         
         # Determine if we should break to new line/stanza
         should_break_stanza = gap >= stanza_gap_threshold and current_line
         should_break_line = (gap >= line_gap_threshold and current_line) or \
                            (current_line_chars + len(word) + 1 > max_chars_per_line and current_line)
         
+        # Check for uppercase-based break (fallback when timing gaps don't produce breaks)
+        should_break_uppercase = False
+        if uppercase_break and current_line and starts_with_uppercase(word):
+            # Break if current line exceeds minimum thresholds
+            if current_line_chars >= min_chars_before_upper_break or \
+               current_line_words >= min_words_before_upper_break:
+                should_break_uppercase = True
+        
         if should_break_stanza:
             # Flush current line and add stanza break
             lines.append(join_line_words(current_line))
             lines.append('')  # Blank line for stanza separator
             current_line = [word]
             current_line_chars = len(word)
-        elif should_break_line:
+            current_line_words = 1 if word not in PUNCT_NO_SPACE_BEFORE else 0
+        elif should_break_line or should_break_uppercase:
             # Flush current line
             lines.append(join_line_words(current_line))
             current_line = [word]
             current_line_chars = len(word)
+            current_line_words = 1 if word not in PUNCT_NO_SPACE_BEFORE else 0
         else:
             # Add to current line
             current_line = append_word_to_line(current_line, word)
             if len(current_line) > 1:
                 current_line_chars += 1  # Space before word
             current_line_chars += len(word)
+            if word not in PUNCT_NO_SPACE_BEFORE:
+                current_line_words += 1
         
         prev_end = end
     
@@ -287,7 +324,21 @@ def format_lyrics_with_timestamps(
     
     # Check if we have word-level data - if so, use word-based formatting
     has_words = any('words' in seg and seg['words'] for seg in segments)
     if has_words:
-        formatted, words = format_lyrics_from_words(segments)
+        formatted, words = format_lyrics_from_words(
+            segments,
+            max_chars_per_line=config.MAX_CHARS_PER_LINE,
+            line_gap_threshold=config.LINE_GAP_THRESHOLD,
+            stanza_gap_threshold=config.STANZA_GAP_THRESHOLD,
+            uppercase_break=config.ENABLE_UPPERCASE_BREAKS,
+            min_chars_before_upper_break=config.MIN_CHARS_BEFORE_UPPER_BREAK,
+            min_words_before_upper_break=config.MIN_WORDS_BEFORE_UPPER_BREAK
+        )
+        
+        # Log formatted output for debugging
+        newline_count = formatted.count('\n')
+        logger.info(f"[DEBUG] Formatted lyrics: len={len(formatted)}, newlines={newline_count}, repr={repr(formatted[:200])}")
+        
         return formatted, words if include_word_timestamps else None
     
     # Fallback: segment-level formatting
